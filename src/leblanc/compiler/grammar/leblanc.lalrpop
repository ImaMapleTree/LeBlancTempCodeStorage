use std::str::FromStr;
use crate::leblanc::compiler::grammar::constant_evaluation::*;
use crate::leblanc::compiler::grammar::ast::*;
use crate::leblanc::compiler::grammar::ast::make_ast;


grammar;

match {
    // Ignore block comments of /* COMMENT */
    r"/[*][^*]*[*]+(?:[^/*][^*]*[*]+)*/" => {},
} else {
    // Ignore in-line comments: // COMMENT
    r"//[^\n\r]*[\n\r]*" => { },
}
else {
    // Ignore whitespace
    r"\s*" => { },
    _ // Everything else
}

pub File: Vec<ast::Component> = {
    <component:Component*> => component
}

Component: ast::Component = {
    Import,
    Extension,
    Class,
    Trait,
    Enum,
    FunctionDeclaration
}

Import: ast::Component = {
    <l:@L> "using" <name:Word> ";" <r:@R> => make_ast!(l, r, Component, ast::Cmpnt::Import { module: name, import: None }),
    <l:@L> "using" <import:SubImports> "from" <module:Word> ";" <r:@R> => make_ast!(l, r, Component, ast::Cmpnt::Import { module, import: Some(import) }),
    <l:@L> "using" "ext" <extension:Word> "from" <module:Word> ";" <r:@R> => make_ast!(l, r, Component, ast::Cmpnt::ExtImport { module, extension }),
    <l:@L> "using" "extension" <extension:Word> "from" <module:Word> ";" <r:@R> => make_ast!(l, r, Component, ast::Cmpnt::ExtImport { module, extension }),
}

SubImports: Vec<String> = {
    <import:Word> <o: ("," <Word>)*> => {
        let mut o = o;
        o.insert(0, import);
        o
    }
}


Enum: ast::Component = {
    <l:@L> "Enum" <name:Word> <type_params:TypeParameterDeclaration?> "{" <items:OptComma<EnumItem>> "}" <r:@R> => {
        make_ast!(l, r, Component, ast::Cmpnt::Enum { name, type_params, items })
    }
}


Class: ast::Component = {
    <l:@L> "Class" <name:Word> <tr:SuperTraits?> "{" <items:ClassItem*> "}" <r:@R> => {
        make_ast!(l, r, Component, ast::Cmpnt::Class { name, super_traits: tr.unwrap_or_default(), items })
     }
}

pub ClassTest: ast::Component = {
    <l:@L> "Class" <name:Word> <tr:SuperTraits?> "{" <items:ClassItem*> "}" <r:@R> => {
        ast::Component {
            location: Location::new((l, r)),
            data: ast::Cmpnt::Class { name, super_traits: tr.unwrap_or_default(), items }
        }

     }
}

Extension: ast::Component = {
    <l:@L> "Extension" <name:Word> "of" <targets:TypeReturns> "{" <items:ExtensionItem*> "}" <r:@R> => {
        make_ast!(l, r, Component, ast::Cmpnt::Extension { name, targets, items })
    }
}

Trait: ast::Component = {
    <l:@L> "Trait" <name:Word> <tr:SuperTraits?> "{" <items:TraitItem*> "}" <r:@R> => {
        make_ast!(l, r, Component, ast::Cmpnt::Trait { name, super_traits: tr.unwrap_or_default(), items })
    }
}

SuperTraits: Vec<String> = {
    "(" <tr:Word?> <o: ("," <Word>)*> ")" => {
        match tr {
            Some(t) => {
                let mut o = o;
                o.insert(0, t);
                o
            },
            None => o
        }
    }
}

EnumItem: ast::Component = {
    <l:@L> <name:Word> <r:@R> => make_ast!(l, r, Component, ast::Cmpnt::EnumItem { name, nested: vec![]}),
    <l:@L> <name:Word> <r:@R> "(" <nested:TypeReturns?> ")" => make_ast!(l, r, Component, ast::Cmpnt::EnumItem { name, nested: nested.unwrap_or_default()}),
}

ClassItem: ast::Component = {
    <l:@L> <typing:Type> <ident:Word> "=" <value:WeakExpression> ";" <r:@R> => make_ast!(l, r, Component, ast::Cmpnt::Property { typing, ident, value: Some(value) }),
    <item:FunctionDeclaration> => item
}

ExtensionItem: ast::Component = {
    <l:@L> "property" <typing:Type> <ident:Word> "=" <value:WeakExpression> ";" <r:@R> => make_ast!(l, r, Component, ast::Cmpnt::Property { typing, ident, value: Some(value) }),
    <item:Property> ";" => item,
    <item:FunctionDeclaration> => item
}

TraitItem: ast::Component = {
    <item:Property> ";" => item,
    <item:FuncHeader> ";" => item
}

Property: ast::Component = {
    <l:@L> "property" <typing:Type> <ident:Word> <r:@R> => make_ast!(l, r, Component, ast::Cmpnt::Property { typing, ident, value: None })
}

FunctionDeclaration: ast::Component = {
    <l:@L> <tags: FuncTags*> <header:FuncHeader> <body: BlockStatement> <r:@R> => {
        let tags: Vec<String> = tags.iter().cloned().flatten().collect();
        make_ast!(l, r, Component, ast::Cmpnt::Function { header: Box::new(header), body, tags })
    }
}

FuncTags: Vec<String> = {
    "<|" <tag1:Word> <other: ("," <Word>)*> "|>" => {
        let mut other = other;
        other.insert(0, tag1);
        other
    }
}

FuncHeader: ast::Component = {
    <l:@L> "func" <name:Word> "(" <params:TypeArg?> ")" <ret: ("returns" <TypeReturns>)?> <r:@R> => {
        let args = match params {
            Some(c) => c,
            None => vec![]
        };
        let returns = match ret {
            Some(c) => c,
            None => vec![]
        };
        make_ast!(l, r, Component, ast::Cmpnt::FunctionHeader { name, args, returns })
    }
}

TypeArg: Vec<ast::Expression> = {
    <ident:FunctionHeaderType> <o: ("," <FunctionHeaderType>)*> => {
        let mut o = o;
        o.insert(0, ident);
        o
    }
}

FunctionHeaderType: ast::Expression = {
    TypedAssignmentPrefix,
    <l:@L> "$" <variable:Word> <r:@R> => make_ast!(l, r, Expression, ast::Expr::TypedVariable { typing: ast::Type::SuperLambda, variable }),
}

TypeReturns: Vec<ast::Type> = {
    <ident:Type> <o: ("," <Type>)*> => {
        let mut o = o;
        o.insert(0, ident);
        o
    }
}

TypeParameterDeclaration: Vec<String> = {
    "<" <ident:Word> <o: ("," <Word>)*> ">" => {
        let mut o = o;
        o.insert(0, ident);
        o
    }
}


GlobalStatement: ast::Statement = {
    <l:@L>"global" <statement:Statement> <r:@R> => make_ast!(l, r, Statement, ast::Stmnt::Global { statement: Box::new(statement) }),
    Statement,
}

Statement: ast::Statement = {
    TryStatement,
    ExceptStatement,
    ForLoop,
    InfLoop,
    WhileLoop,
    ConditionalIf,
    ConditionalElseIf,
    ConditionalElse,
    RefStatement
}

RefStatement: ast::Statement = {
    ReturnStatement,
    CommonStatement,
}

CommonStatement: ast::Statement = {
    LineStatement,
    BlockStatement
}

ResolveStatement: ast::Statement = {
    LineStatement,
    ReturnStatement
}

LineStatement: ast::Statement = {
    <l:@L> <expr:Expression> ";" <r:@R> => make_ast!(l, r, Statement, ast::Stmnt::Line { expr }),
}

BlockStatement: ast::Statement = {
    <l:@L> "{" <s:Statement*> "}" <r:@R> => make_ast!(l, r, Statement, ast::Stmnt::Block { statements: s }),
}

ReturnStatement: ast::Statement = {
    <l:@L> "return" <common:CommonStatement> <r:@R> => make_ast!(l, r, Statement, ast::Stmnt::Return { statement: Box::new(common) })
}

TryStatement: ast::Statement = {
    <l:@L> "try" <statement:BlockStatement> <r:@R> => make_ast!(l, r, Statement, ast::Stmnt::Try { statement: Box::new(statement)}),
    <l:@L> "try" ":" <statement:ResolveStatement> <r:@R> => make_ast!(l, r, Statement, ast::Stmnt::Try { statement: Box::new(statement)}),
}

ExceptStatement: ast::Statement = {
    <l:@L> "except" <catch:ExceptParameters?> <statement:BlockStatement> <r:@R> => make_ast!(l, r, Statement, ast::Stmnt::Except { catch, statement: Box::new(statement)}),
    <l:@L> "except" <catch:ExceptParameters?> ":" <statement:ResolveStatement> <r:@R> => make_ast!(l, r, Statement, ast::Stmnt::Except { catch, statement: Box::new(statement)}),
}

ExceptParameters: ast::Expression = {
    <l:@L> "(" <errors:TypeReturns> <variable:Word> ")" <r:@R> => make_ast!(l, r, Expression, ast::Expr::ExceptCatch { errors, variable })
}

ForLoop: ast::Statement = {
    <l:@L> "for" <variable:TypedAssignmentPrefix> "in" <iterable: WeakExpression> <statement:BlockStatement> <r:@R> => {
        make_ast!(l, r, Statement, ast::Stmnt::For { variable, iterable, statement: Box::new(statement) })
    },
    <l:@L> "for" <variable:TypedAssignmentPrefix> "in" <iterable: WeakExpression> ":" <statement:ResolveStatement> <r:@R> => {
        make_ast!(l, r, Statement, ast::Stmnt::For { variable, iterable, statement: Box::new(statement) })
    },
}


InfLoop: ast::Statement = {
    <l:@L> "loop" <statement:BlockStatement> <r:@R> => make_ast!(l, r, Statement, ast::Stmnt::InfLoop { statement: Box::new(statement)}),
    <l:@L> "loop" ":" <statement:ResolveStatement> <r:@R> => make_ast!(l, r, Statement, ast::Stmnt::InfLoop { statement: Box::new(statement)}),
}

WhileLoop: ast::Statement = {
    <l:@L> "while" <weak:WeakExpression> <statement:BlockStatement> <r:@R> => make_ast!(l, r, Statement, ast::Stmnt::While { condition: weak, statement: Box::new(statement)}),
    <l:@L> "while" <weak:WeakExpression> ":" <statement:ResolveStatement> <r:@R> => make_ast!(l, r, Statement, ast::Stmnt::While { condition: weak, statement: Box::new(statement)}),
}

ConditionalIf: ast::Statement = {
    <l:@L> "if" <weak:WeakExpression> <statement:BlockStatement> <r:@R> => make_ast!(l, r, Statement, ast::Stmnt::Conditional { conditional: ast::Conditional::If { condition: weak, statement: Box::new(statement) } }),
    <l:@L> "if" <weak:WeakExpression> ":" <statement:ResolveStatement> <r:@R> => make_ast!(l, r, Statement, ast::Stmnt::Conditional { conditional: ast::Conditional::If { condition: weak, statement: Box::new(statement) } }),
}

ConditionalElseIf: ast::Statement = {
    <l:@L> "else if" <weak:WeakExpression> <statement:BlockStatement> <r:@R> => make_ast!(l, r, Statement, ast::Stmnt::Conditional { conditional: ast::Conditional::ElseIf { condition: weak, statement: Box::new(statement) } }),
    <l:@L> "else if" <weak:WeakExpression> ":" <statement:ResolveStatement> <r:@R> => make_ast!(l, r, Statement, ast::Stmnt::Conditional { conditional: ast::Conditional::ElseIf { condition: weak, statement: Box::new(statement) } }),
}

ConditionalElse: ast::Statement = {
    <l:@L> "else" <statement:BlockStatement> <r:@R> => make_ast!(l, r, Statement, ast::Stmnt::Conditional { conditional: ast::Conditional::Else { statement: Box::new(statement) } }),
    <l:@L> "else" ":" <statement:ResolveStatement> <r:@R> => make_ast!(l, r, Statement, ast::Stmnt::Conditional { conditional: ast::Conditional::Else { statement: Box::new(statement) } }),
}

Expression: ast::Expression = {
    WeakExpression,
    Assignment,
    <l:@L> "break" <r:@R> => make_ast!(l, r, Expression, ast::Expr::Break),
}

WeakExpression: ast::Expression = {
    GroupExpression,
}

GroupExpression: ast::Expression = {
    <l:@L> <assignee:Lambda> <r:@R> "->" <group:LowLevelTerm> => make_ast!(l, r, Expression, ast::Expr::GroupAssignment { assignee: Box::new(assignee), group: Box::new(group) }),
    Lambda
}

Assignment: ast::Expression = {
    ListAssignment,
    MultiAssignment
}

ListAssignment: ast::Expression = {
    <l:@L> <list:ListIndex> "=" <expr:WeakExpression> <r:@R> => make_ast!(l, r, Expression, ast::Expr::ListAssignment { list: Box::new(list), expr: Box::new(expr) })
}

MultiAssignment: ast::Expression = {
    <l:@L> <d:TypedAssignmentPrefix> <o: ("," <TypedAssignmentPrefix>)*> <a: ("=" <WeakExpression>)?> <r:@R> => {
        let mut o = o;
        o.insert(0, d);
        make_ast!(l, r, Expression, ast::Expr::TypedAssignment { idents: o, expr: a.map(Box::new)})
    },
    MultiNormalAssignment
}

TypedAssignmentPrefix: ast::Expression = {
    <l:@L> "Self" <r:@R> => make_ast!(l, r, Expression, ast::Expr::TypedVariable { typing: ast::Type::SelfRef, variable: "Self".to_string() }),
    <l:@L> <typing:Type> <ident:Word> <r:@R> => make_ast!(l, r, Expression, ast::Expr::TypedVariable { typing, variable: ident }),
}

MultiNormalAssignment: ast::Expression = {
     <l:@L> <chained: ChainedIdent> "=" <expr:WeakExpression> <r:@R> => make_ast!(l, r, Expression, ast::Expr::NormalAssignment { idents: chained, expr: Box::new(expr) })
}


RangeExpression: ast::Expression = {
    <l:@L> <start:NotExpression> "to" <bound:NotExpression> <step: ("by" <Lambda>)?> <r:@R> => {
        let step = Box::new(match step {
            Some(s) => s,
            None => make_ast!(l, r, Expression, ast::Expr::Constant { constant: ast::Const::Whole(1) })
        });
        make_ast!(l, r, Expression, ast::Expr::RangeExpression { start: Box::new(start), bound: Box::new(bound), step })
    },
    NotExpression
}

Lambda: ast::Expression = {
    <l:@L> "|" <chained: ChainedIdent?> "|" <block: BlockStatement> <r:@R> => {
        let variables = match chained {
            Some(c) => c,
            None => vec![]
        };
        make_ast!(l, r, Expression, ast::Expr::BlockLambda { variables, block: Box::new(block) })
    },
    <l:@L> "|" <chained: ChainedIdent?> "|" <expr: Lambda> <r:@R> => {
        let variables = match chained {
            Some(c) => c,
            None => vec![]
        };
        make_ast!(l, r, Expression, ast::Expr::ExprLambda { variables, expr: Box::new(expr) })
    },
    RangeExpression
}

ChainedIdent: Vec<ast::Ident> = {
    <ident:ObjIdent> <o: ("," <ObjIdent>)*> => {
        let mut o = o;
        o.insert(0, ident);
        o
    }
}


NotExpression: ast::Expression = {
    <l:@L> "!" <expr:Equality> <r:@R> => make_ast!(l, r, Expression, ast::Expr::UnaryOperation { term: Box::new(expr), op: ast::UnaryOperator::UNot }),
    Equality
}

Equality: ast::Expression = {
    <l:@L> <left: Equality> <comparator: Comparator> <right: BinaryAdditive> <r:@R> => make_ast!(l, r, Expression, ast::Expr::Equality { left: Box::new(left), comparator, right: Box::new(right) }),
    BinaryAdditive
}

BinaryAdditive: ast::Expression = {
    <l:@L> <left:BinaryAdditive> <op: ArithPlusMinusOperator> <right: BinaryMultiplicative> <r:@R> => {
        if let ast::Expr::Constant { ref constant } = left.data {
            let c1 = constant;
            if let ast::Expr::Constant { ref constant } = right.data {
                let func = match op {
                    ast::BinaryOperator::BinAdd => add_constants,
                    ast::BinaryOperator::BinSub => sub_constants,
                    _ => return make_ast!(l, r, Expression, ast::Expr::ArithPlusMinusOperation { left: Box::new(left), op, right: Box::new(right) })
                };
                if let Ok(constant) = func(c1.clone(), constant.clone()) {
                   return make_ast!(l, r, Expression, ast::Expr::Constant { constant })
                }
            }
        }
        make_ast!(l, r, Expression, ast::Expr::ArithPlusMinusOperation { left: Box::new(left), op, right: Box::new(right) })
    },
    BinaryMultiplicative
}


BinaryMultiplicative: ast::Expression = {
    <l:@L> <left:BinaryMultiplicative> <op: ArithMulDivModOperator> <right: BinaryExponential> <r:@R> => {
        if let ast::Expr::Constant { ref constant } = left.data {
            let c1 = constant;
            if let ast::Expr::Constant { ref constant } = right.data {
                let func = match op {
                    ast::BinaryOperator::BinMul => mul_constants,
                    ast::BinaryOperator::BinDiv => div_constants,
                    ast::BinaryOperator::BinMod => mod_constants,
                    _ => return make_ast!(l, r, Expression, ast::Expr::ArithMulDivModOperation { left: Box::new(left), op, right: Box::new(right) })
                };
                if let Ok(constant) = func(c1.clone(), constant.clone()) {
                    return make_ast!(l, r, Expression,  ast::Expr::Constant { constant })
                }
            }
        }
        make_ast!(l, r, Expression, ast::Expr::ArithMulDivModOperation { left: Box::new(left), op, right: Box::new(right) })
    },
    BinaryExponential
}


BinaryExponential: ast::Expression = {
    <l:@L> <left:BinaryExponential> <op: ExponentOperator> <right: ConstantFactor> <r:@R> => {
            if let ast::Expr::Constant { ref constant } = left.data {
                let c1 = constant;
                if let ast::Expr::Constant { ref constant } = right.data {
                    if let Ok(constant) = pow_constants(c1.clone(), constant.clone()) {
                        return make_ast!(l, r, Expression, ast::Expr::Constant { constant })
                    }
                }
            }
            make_ast!(l, r, Expression, ast::Expr::ExponentialOperation { left: Box::new(left), op, right: Box::new(right) })
        },
    ConstantFactor
}

ConstantFactor: ast::Expression = {
    ConstantTerm,
    UnaryFactor
}

UnaryFactor: ast::Expression = {
    <l:@L> <u:UnaryOperator> <f:UnaryFactor> <r:@R> => make_ast!(l, r, Expression, ast::Expr::UnaryOperation { term: Box::new(f), op: u }),
    PostFixFactor
}

PostFixFactor: ast::Expression = {
    <l:@L> <factor: PreFixFactor> <op: IncDecOperator> <r:@R> => make_ast!(l, r, Expression, ast::Expr::IncrementDecrementOperation { term: Box::new(factor), op, postfix: true }),
    PreFixFactor
}

PreFixFactor: ast::Expression = {
    <l:@L> <op: IncDecOperator> <factor: PreFixFactor> <r:@R> => make_ast!(l, r, Expression, ast::Expr::IncrementDecrementOperation { term: Box::new(factor), op, postfix: false }),
    LowLevelTerm,
}

LowLevelFactor: ast::Expression = {
    LowLevelTerm,
}

LowLevelTerm: ast::Expression = {
    <l:@L> <i: LowLevelTerm> "(" <e:ExprList> ")" <r:@R> => make_ast!(l, r, Expression, ast::Expr::StaticMethodCall { method_name: Box::new(i), args: e}),
    <l:@L> "[" <items:ExprList> "]" <r:@R> => make_ast!(l, r, Expression, ast::Expr::List {items}),
    ListIndex,
    <l:@L> <i:ObjIdent> <r:@R> => make_ast!(l, r, Expression, ast::Expr::Ident { ident: i}),
    "(" <expr:WeakExpression> ")" => expr,
}

ListIndex: ast::Expression = {
    <l:@L> <i:LowLevelTerm> "[" <left:WeakExpression> ":" <right:WeakExpression> "]" <r:@R> => {
        make_ast!(l, r, Expression, ast::Expr::ListIndex { list: Box::new(i), slice: Box::new(ast::Expr::Slice {
                left: Box::new(left),
                right: Box::new(right)
            })
        })
    },
    <l:@L> <i:LowLevelTerm> "[" <first:WeakExpression> <indices:CommaExpr> "]" <r:@R> => {
        let mut indices = indices;
        indices.insert(0, first);
        make_ast!(l, r, Expression, ast::Expr::ListIndex { list: Box::new(i), slice: Box::new(ast::Expr::SeriesIndex {
                indices

            })
        })
    },
}

ConstantTerm: ast::Expression = {
    <l:@L> <c:Number> <r:@R> => make_ast!(l, r, Expression, ast::Expr::Constant { constant: ast::Const::Whole(c) }),
    <l:@L> <c:Float> <r:@R> => make_ast!(l, r, Expression, ast::Expr::Constant { constant: ast::Const::Float(c) }),
    <l:@L> <c:StringLiteral> <r:@R> => make_ast!(l, r, Expression, ast::Expr::Constant { constant: ast::Const::String(c) }),
    <l:@L> <c:Boolean> <r:@R> => make_ast!(l, r, Expression, ast::Expr::Constant { constant: ast::Const::Boolean(c) }),
}


ExprList: Vec<ast::Expression> = {
    <ex1: WeakExpression?> <ex2: CommaExpr> => {
        match ex1 {
            Some(e) => {
                let mut v = ex2.to_vec();
                v.insert(0, e);
                v
            },
            None => vec![]
        }

    }
}

CommaExpr: Vec<ast::Expression> = {
    <t: ("," <WeakExpression>)*> => {
        t.to_vec()
    }
}

ObjIdent: ast::Ident = {
    EnumIdent,
    <l:@L> <i: ObjIdent> "." <o:EnumIdent> <r:@R> => make_ast!(l, r, Ident, ast::Id::ObjIdent { ident: Box::new(i), attr: Box::new(o)}),
}

EnumIdent: ast::Ident = {
    Ident,
    <l:@L> <i: EnumIdent> "::" <o:Ident> <r:@R> => make_ast!(l, r, Ident, ast::Id::EnumIdent { ident: Box::new(i), kind: Box::new(o)}),
}

Ident: ast::Ident = {
    <l:@L> <id:Word> <r:@R> => make_ast!(l, r, Ident, ast::Id::Ident { ident: id.to_string() }),
}

#[inline]
Word: String = {
    <r"[A-Za-z]\w*"> => <>.to_string()
}

Type: ast::Type = {
    "string" => ast::Type::String,
    "float" => ast::Type::Float,
    "flex" => ast::Type::Flex,
    "int" => ast::Type::Int,
    "function" => ast::Type::Function,
    "group" => ast::Type::Group,
    "promise" => ast::Type::Promise,
    "Self" => ast::Type::SelfRef,
    <w:Word> "!" => ast::Type::Trait(w, true),
    <w:Word> "?" => ast::Type::Trait(w, false),
    <w:Word> => ast::Type::Class(w)
}

Boolean: bool = {
    "false" => false,
    "true" => true
}

Float: f64 = {
    <l: r"\d+"> "." <r: r"\d+"> => f64::from_str(&(l.to_string() + "." + &r.to_string())).unwrap()
}

Number: i128 = {
    <s:r"\d+"> => i128::from_str(s).unwrap(),
}

StringLiteral: String = {
    <s:r#""[^"]*""#> => s[1..s.len()-1].to_string(),
    <s:r"'[^']*'"> => s[1..s.len()-1].to_string()
}

ArithPlusMinusOperator: ast::BinaryOperator = {
    "+" => ast::BinaryOperator::BinAdd,
    "-" => ast::BinaryOperator::BinSub,
}

ArithMulDivModOperator: ast::BinaryOperator = {
    "*" => ast::BinaryOperator::BinMul,
    "/" => ast::BinaryOperator::BinDiv,
    "%" => ast::BinaryOperator::BinMod,
}

ExponentOperator: ast::BinaryOperator = {
    "**" => ast::BinaryOperator::BinPow,
}

IncDecOperator: ast::UnaryOperator = {
    "++" => ast::UnaryOperator::UIncrement,
    "--" => ast::UnaryOperator::UDecrement,
}

UnaryOperator: ast::UnaryOperator = {
    "+" => ast::UnaryOperator::UPositive,
    "-" => ast::UnaryOperator::UNegative,
    "~" => ast::UnaryOperator::UInverse,
}

Comparator: ast::Comparator = {
    "==" => ast::Comparator::Equal,
    "!=" => ast::Comparator::NotEqual,
    ">=" => ast::Comparator::GreaterEqual,
    "<=" => ast::Comparator::LesserEqual,
    ">" => ast::Comparator::Greater,
    "<" => ast::Comparator::Lesser,
    "in" => ast::Comparator::In,
}

ConditionType: ast::CondType = {
    "if" => ast::CondType::If,
    "else if" => ast::CondType::ElseIf,
    "else" => ast::CondType::Else
}

#[inline]
Comma<T>: Vec<T> = {
    <first: T> <items: ("," <T>)*> => {
        let mut items = items;
        items.insert(0, first);
        items
    }
};

#[inline]
OptComma<T>: Vec<T> = {
    <items: (<T> ",")*> <last: T?> => {
        let mut items = items;
        items.extend(last);
        items
    }
};
